# Required vars:
# WANTED_MODULE_NAME
# WANTED_INCLUDES
# WANTED_LIBRARIES

# Optional vars:
# WANTED_INCLUDES_PATH
# WANTED_LIBRARIES_PATH
# WANTED_DEBUG_SUFFIX ('d' if not specified)

# Produced vars:
# ${WANTED_MODULE_NAME}_FOUND
# ${WANTED_MODULE_NAME}_LIBRARY_RELEASE
# ${WANTED_MODULE_NAME}_LIBRARY_DEBUG
# ${WANTED_MODULE_NAME}_LIBRARY
# ${WANTED_MODULE_NAME}_LIBRARIES
# ${WANTED_MODULE_NAME}_INCLUDE_DIR

LIST ( APPEND WANTED_INCLUDES_PATH
	/usr/local
	/usr
	/sw # Fink
	/opt/local # DarwinPorts
	/opt/csw # Blastwave
	/opt
    $ENV{PROGRAMFILES}/${WANTED_MODULE_NAME}
    $ENV{${WANTED_MODULE_NAME}DIR}
    $ENV{${WANTED_MODULE_NAME}_DIR}
)

LIST ( APPEND WANTED_LIBRARIES_PATH
	~/Library/Frameworks
	/Library/Frameworks
	/usr/local
	/usr
	/sw # Fink
	/opt/local # DarwinPorts
	/opt/csw # Blastwave
	/opt
    $ENV{PROGRAMFILES}/${WANTED_MODULE_NAME}
    $ENV{${WANTED_MODULE_NAME}DIR}
    $ENV{${WANTED_MODULE_NAME}_DIR}
)

# find includes
FIND_PATH (${WANTED_MODULE_NAME}_INCLUDE_DIR
	NAMES ${WANTED_INCLUDES}
	PATH_SUFFIXES include
	PATHS ${WANTED_INCLUDES_PATH}
)

# find libraries
FIND_LIBRARY (${WANTED_MODULE_NAME}_LIBRARY_RELEASE
	NAMES ${WANTED_LIBRARIES}
	PATH_SUFFIXES lib64 lib
	PATHS ${WANTED_LIBRARIES_PATH}
)

IF (NOT WANTED_DEBUG_SUFFIX)
	SET (WANTED_DEBUG_SUFFIX d)
ENDIF (NOT WANTED_DEBUG_SUFFIX)

SET (WANTED_LIBRARIES_DEBUG "")
FOREACH (lib ${WANTED_LIBRARIES})
	SET (WANTED_LIBRARIES_DEBUG ${WANTED_LIBRARIES_DEBUG} ${lib}${WANTED_DEBUG_SUFFIX})
ENDFOREACH (lib)

FIND_LIBRARY (${WANTED_MODULE_NAME}_LIBRARY_DEBUG
	NAMES ${WANTED_LIBRARIES_DEBUG}
	PATH_SUFFIXES lib64 lib
	PATHS ${WANTED_LIBRARIES_PATH} 
)

# setup debug/optimized versions
IF (${WANTED_MODULE_NAME}_LIBRARY_RELEASE AND ${WANTED_MODULE_NAME}_LIBRARY_DEBUG)
	SET (${WANTED_MODULE_NAME}_LIBRARIES optimized ${${WANTED_MODULE_NAME}_LIBRARY_RELEASE} debug ${${WANTED_MODULE_NAME}_LIBRARY_DEBUG})
	# if the generator supports configuration types then set
	# optimized and debug libraries, or if the CMAKE_BUILD_TYPE has a value
	IF (CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
		SET (${WANTED_MODULE_NAME}_LIBRARY ${${WANTED_MODULE_NAME}_LIBRARIES})
	ELSE (CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
		# if there are no configuration types and CMAKE_BUILD_TYPE has no value
		# then just use the release libraries
		SET (${WANTED_MODULE_NAME}_LIBRARY ${${WANTED_MODULE_NAME}_LIBRARY_RELEASE})
	ENDIF (CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
ENDIF (${WANTED_MODULE_NAME}_LIBRARY_RELEASE AND ${WANTED_MODULE_NAME}_LIBRARY_DEBUG)

IF (${WANTED_MODULE_NAME}_LIBRARY_RELEASE AND NOT ${WANTED_MODULE_NAME}_LIBRARY_DEBUG)
	SET (${WANTED_MODULE_NAME}_LIBRARY_DEBUG	${${WANTED_MODULE_NAME}_LIBRARY_RELEASE})
	SET (${WANTED_MODULE_NAME}_LIBRARY			${${WANTED_MODULE_NAME}_LIBRARY_RELEASE})
	SET (${WANTED_MODULE_NAME}_LIBRARIES		${${WANTED_MODULE_NAME}_LIBRARY_RELEASE})
ENDIF (${WANTED_MODULE_NAME}_LIBRARY_RELEASE AND NOT ${WANTED_MODULE_NAME}_LIBRARY_DEBUG)

IF (${WANTED_MODULE_NAME}_LIBRARY_DEBUG AND NOT ${WANTED_MODULE_NAME}_LIBRARY_RELEASE)
	SET (${WANTED_MODULE_NAME}_LIBRARY_RELEASE	${${WANTED_MODULE_NAME}_LIBRARY_DEBUG})
	SET (${WANTED_MODULE_NAME}_LIBRARY			${${WANTED_MODULE_NAME}_LIBRARY_DEBUG})
	SET (${WANTED_MODULE_NAME}_LIBRARIES		${${WANTED_MODULE_NAME}_LIBRARY_DEBUG})
ENDIF (${WANTED_MODULE_NAME}_LIBRARY_DEBUG AND NOT ${WANTED_MODULE_NAME}_LIBRARY_RELEASE)

SET (DEPENDENCY_INCLUDE_DIR)
SET (DEPENDENCY_LIBRARIES)
FOREACH (Dependency ${WANTED_DEPENDENCIES})
	STRING (TOUPPER ${Dependency} DEPENDENCY_UPPERCASE)
	IF (${DEPENDENCY_UPPERCASE}_FOUND OR ${Dependency}_FOUND)
		LIST (APPEND DEPENDENCY_INCLUDE_DIR  ${${Dependency}_INCLUDE_DIR})
		IF (${Dependency}_LIBRARIES)
			LIST (APPEND DEPENDENCY_LIBRARIES 	 ${${Dependency}_LIBRARIES})
		ELSEIF (${DEPENDENCY_UPPERCASE}_LIBRARIES)
			LIST (APPEND DEPENDENCY_LIBRARIES 	 ${${DEPENDENCY_UPPERCASE}_LIBRARIES})
		ELSEIF (${Dependency}_LIBRARY)
			LIST (APPEND DEPENDENCY_LIBRARIES 	 ${${Dependency}_LIBRARY})
		ELSEIF (${DEPENDENCY_UPPERCASE}_LIBRARY)
			LIST (APPEND DEPENDENCY_LIBRARIES 	 ${${DEPENDENCY_UPPERCASE}_LIBRARY})
		ELSE (${Dependency}_LIBRARIES)
			MESSAGE (STATUS "${WANTED_MODULE_NAME} dependency doesn't have library variable")
		ENDIF (${Dependency}_LIBRARIES)
	ELSE (${DEPENDENCY_UPPERCASE}_FOUND OR ${Dependency}_FOUND)
		IF (${WANTED_MODULE_NAME}_FIND_REQUIRED)
			MESSAGE (FATAL_ERROR "Dependency ${Dependency} of package ${WANTED_MODULE_NAME} not found")
		ELSE (${WANTED_MODULE_NAME}_FIND_REQUIRED)
			MESSAGE (STATUS "Dependency ${Dependency} of package ${WANTED_MODULE_NAME} not found")
		ENDIF (${WANTED_MODULE_NAME}_FIND_REQUIRED)
		SET( ${WANTED_MODULE_NAME}_FOUND FALSE )
		RETURN()
	ENDIF (${DEPENDENCY_UPPERCASE}_FOUND OR ${Dependency}_FOUND)
ENDFOREACH (Dependency ${WANTED_DEPENDENCIES})

INCLUDE (FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS (${WANTED_MODULE_NAME} DEFAULT_MSG ${WANTED_MODULE_NAME}_LIBRARY ${WANTED_MODULE_NAME}_INCLUDE_DIR)

LIST (APPEND ${WANTED_MODULE_NAME}_INCLUDE_DIR 	${DEPENDENCY_INCLUDE_DIR})
LIST (APPEND ${WANTED_MODULE_NAME}_LIBRARIES 	${DEPENDENCY_LIBRARIES})

# Reset variables (because scopes only creates in directories and functions)
SET (WANTED_INCLUDES_PATH)
SET (WANTED_LIBRARIES_PATH)
SET (WANTED_DEBUG_SUFFIX)
